<!DOCTYPE html>
<html>
<head><title>Maze</title>
<style>
	html, body { margin: 0; padding: 0; height: 100% }
	#playground { position: relative; margin: 0 auto;}
	#playground canvas {
		position: absolute;
		left: 0;
		top: 0;
	}
</style>
</head>
<body>
	<div id="playground"></div>
	<script>
		let playground = document.querySelector('#playground'),
			maze = document.createElement('canvas'),
			playerMap = document.createElement('canvas'),
			mazeContext = maze.getContext('2d'),
			playerContext = playerMap.getContext('2d'),
			playWidth = 800,
			maxDifficulty = 4,
			difficulty = 3,
			columns = playWidth / ((maxDifficulty-difficulty + 1) * 10) <<0,
			lines = (columns * (9/16) ) << 0,
			tileSize = (playWidth / columns) << 0,
			i, total = columns * lines,
			tiles = [],
			finished = false,
			current = 0,
			playerPosition = 0,
			moves = 0;
		
		playground.appendChild(playerMap);
		playground.appendChild(maze);
		
		[maze, playerMap].forEach(canvas => {
			canvas.width = columns*tileSize;
			canvas.height = lines*tileSize;
		});
		
		playground.style.width = (columns*tileSize) + 'px';
		playground.style.height = (lines*tileSize) + 'px';
		
		function randomPosition() {
			return Math.random() * tiles.length << 0;
		}
		
		function indexFromPosition(position) {
			return position ? position.y * columns + position.x : -1;
		}
		
		function positionFromIndex(index) {
			return {
				x: index % columns, 
				y: ((index / columns) << 0)
			};
		}
			
		function neighboursFromPosition(position) {
			/*
			    | y-1|
			____|____|____
			 x-1|  x |x+1  
			____|____|____
                | y+1|    
                |	 |			
			*/
			
			return [
				{x: position.x, y: position.y - 1},
				{x: position.x + 1, y: position.y},
				{x: position.x, y: position.y + 1},
				{x: position.x - 1, y: position.y}
			].map(p => p.x >=0 && p.y >=0 && p.x < columns && p.y < lines ? p : null)
			.map(indexFromPosition);
		}
		
		function getTileOrigin(tile) {
			return [tile.position.x * tileSize, tile.position.y * tileSize];
		};
		
		function draw(tile) {
			let openNeighbours = tile.neighbours
					.filter(index => [tile.from, ...tile.to].indexOf(index) != -1)
					.map(open => tile.neighbours.indexOf(open)),
				origin = getTileOrigin(tile);
				rect = [...origin, tileSize, tileSize],
				strokes = [
					[origin[0] + tileSize, origin[1]],
					[origin[0] + tileSize, origin[1] + tileSize],
					[origin[0], origin[1] + tileSize],
					origin
				];

			strokes.filter((stroke, index) => openNeighbours.indexOf(index) === -1)
				.forEach(stroke => {
					mazeContext.moveTo(...strokes[(4+(strokes.indexOf(stroke)-1))%4]);
					mazeContext.lineTo(...stroke);
				});
		}
		
		function selectNextTile(tile) {
			let candidates = tile.neighbours.filter(index => index >= 0 && !tiles[index].visited);
			return candidates.length > 0
				? candidates[Math.random()*candidates.length <<0]
				: false;
		}
		
		function generateMaze() {
			current = randomPosition();
			for (i = 0; i < total; i += 1) {
				let position = positionFromIndex(i);
				tiles.push({
					index: i,
					position: position,
					neighbours : neighboursFromPosition(position),
					visited : false,
					from : null,
					to : [],
					playerVisite: 0
				});
			}
		}
		
		function next() {
			tiles[current].visited = true;
			let nextIndex = selectNextTile(tiles[current]);
			
			if (nextIndex !== false) {
				tiles[current].to.push(nextIndex);
				tiles[nextIndex].from = current;
				current = nextIndex;
			} else {
				current = tiles[current].from;
				if (current === null) {
					finished = true;
				} else {
					tiles[current].backTracked = true;
				}
			}
		};
		
		function drawMaze() {
			let s = new Date().getTime();
			while(!finished) {
				next();
			}
			tiles.forEach(tile => draw(tile));
			mazeContext.stroke();
			console.log(new Date().getTime() - s);
		}
		
		function updatePlayerPos(direction) {
			let tile = tiles[playerPosition];
				newPos = tiles[playerPosition].neighbours[direction];
				
			if (newPos !== -1 && [tile.from, ...tile.to].indexOf(newPos) !== -1) {
				playerPosition = newPos;
				tile.playerVisite += 1,
				drawPlayer();
				moves++;
				
				if (newPos === tiles.length - 1) {
					setTimeout(() => alert('Finis en ' + moves + ' mouvements'));
				}
			}
			
		}
		
		function drawPlayer() {
			playerContext.clearRect(0, 0, columns * tileSize, lines * tileSize);
			
			tiles.forEach(tile => {
				let origin = getTileOrigin(tile);
				playerContext.fillStyle = tile.index === playerPosition
					? 'red'
					: 'rgba(0,0,0,' + (tile.playerVisite * 0.1) + ')';
					
				playerContext.fillRect(...origin, tileSize, tileSize);
			});
		}
		
		generateMaze();
		drawMaze();
		playerPosition = indexFromPosition({x: (columns/4) <<0, y: (lines/4)<<0});
		drawPlayer();
		
		document.addEventListener('keydown', (ev) => {
			let key = ['ArrowUp', 'ArrowRight', 'ArrowDown', 'ArrowLeft'].indexOf(ev.code);
			if (key !== -1) {
				updatePlayerPos(key);
			}
		});
		
	</script>
</body>
</html>